=== tests/cases/conformance/types/typeParameters/typeArgumentLists/instantiationExpressionErrors.ts ===
declare let f: { <T>(): T, g<U>(): U };
>f : Symbol(f, Decl(instantiationExpressionErrors.ts, 0, 11))
>T : Symbol(T, Decl(instantiationExpressionErrors.ts, 0, 18))
>T : Symbol(T, Decl(instantiationExpressionErrors.ts, 0, 18))
>g : Symbol(g, Decl(instantiationExpressionErrors.ts, 0, 26))
>U : Symbol(U, Decl(instantiationExpressionErrors.ts, 0, 29))
>U : Symbol(U, Decl(instantiationExpressionErrors.ts, 0, 29))

// Type arguments in member expressions

const a1 = f<number>;  // { (): number; g<U>(): U; }
>a1 : Symbol(a1, Decl(instantiationExpressionErrors.ts, 4, 5))
>f : Symbol(f, Decl(instantiationExpressionErrors.ts, 0, 11))

const a2 = f.g<number>;  // () => number
>a2 : Symbol(a2, Decl(instantiationExpressionErrors.ts, 5, 5))
>f.g : Symbol(g, Decl(instantiationExpressionErrors.ts, 0, 26))
>f : Symbol(f, Decl(instantiationExpressionErrors.ts, 0, 11))
>g : Symbol(g, Decl(instantiationExpressionErrors.ts, 0, 26))

const a3 = f<number>.g;  // <U>() => U
>a3 : Symbol(a3, Decl(instantiationExpressionErrors.ts, 6, 5))
>f<number>.g : Symbol(g, Decl(instantiationExpressionErrors.ts, 0, 26))
>f : Symbol(f, Decl(instantiationExpressionErrors.ts, 0, 11))
>g : Symbol(g, Decl(instantiationExpressionErrors.ts, 0, 26))

const a4 = f<number>.g<number>;  // () => number
>a4 : Symbol(a4, Decl(instantiationExpressionErrors.ts, 7, 5))
>f<number>.g : Symbol(g, Decl(instantiationExpressionErrors.ts, 0, 26))
>f : Symbol(f, Decl(instantiationExpressionErrors.ts, 0, 11))
>g : Symbol(g, Decl(instantiationExpressionErrors.ts, 0, 26))

const a5 = f['g']<number>;  // () => number
>a5 : Symbol(a5, Decl(instantiationExpressionErrors.ts, 8, 5))
>f : Symbol(f, Decl(instantiationExpressionErrors.ts, 0, 11))
>'g' : Symbol(g, Decl(instantiationExpressionErrors.ts, 0, 26))

// `[` is an expression starter and cannot immediately follow a type argument list

const a6 = f<number>['g'];  // Error
>a6 : Symbol(a6, Decl(instantiationExpressionErrors.ts, 12, 5))
>f : Symbol(f, Decl(instantiationExpressionErrors.ts, 0, 11))

const a7 = (f<number>)['g'];
>a7 : Symbol(a7, Decl(instantiationExpressionErrors.ts, 13, 5))
>f : Symbol(f, Decl(instantiationExpressionErrors.ts, 0, 11))
>'g' : Symbol(g, Decl(instantiationExpressionErrors.ts, 0, 26))

// An `<` cannot immediately follow a type argument list

const a8 = f<number><number>;  // Relational operator error
>a8 : Symbol(a8, Decl(instantiationExpressionErrors.ts, 17, 5))
>f : Symbol(f, Decl(instantiationExpressionErrors.ts, 0, 11))

const a9 = (f<number>)<number>;  // Error, no applicable signatures
>a9 : Symbol(a9, Decl(instantiationExpressionErrors.ts, 18, 5))
>f : Symbol(f, Decl(instantiationExpressionErrors.ts, 0, 11))

// Type arguments with `?.` token

const b1 = f?.<number>;  // Error, `(` expected
>b1 : Symbol(b1, Decl(instantiationExpressionErrors.ts, 22, 5))
>f : Symbol(f, Decl(instantiationExpressionErrors.ts, 0, 11))

const b2 = f?.<number>();
>b2 : Symbol(b2, Decl(instantiationExpressionErrors.ts, 23, 5))
>f : Symbol(f, Decl(instantiationExpressionErrors.ts, 0, 11))

const b3 = f<number>?.();
>b3 : Symbol(b3, Decl(instantiationExpressionErrors.ts, 24, 5))
>f : Symbol(f, Decl(instantiationExpressionErrors.ts, 0, 11))

const b4 = f<number>?.<number>();  // Error, expected no type arguments
>b4 : Symbol(b4, Decl(instantiationExpressionErrors.ts, 25, 5))
>f : Symbol(f, Decl(instantiationExpressionErrors.ts, 0, 11))

// Parsed as function call, even though this differs from JavaScript

const x1 = f<true>
>x1 : Symbol(x1, Decl(instantiationExpressionErrors.ts, 29, 5))
>f : Symbol(f, Decl(instantiationExpressionErrors.ts, 0, 11))

(true);

// Parsed as relational expression

const x2 = f<true>
>x2 : Symbol(x2, Decl(instantiationExpressionErrors.ts, 34, 5))
>f : Symbol(f, Decl(instantiationExpressionErrors.ts, 0, 11))

true;

// Parsed as instantiation expression

const x3 = f<true>;
>x3 : Symbol(x3, Decl(instantiationExpressionErrors.ts, 39, 5))
>f : Symbol(f, Decl(instantiationExpressionErrors.ts, 0, 11))

true;

// Parsed as instantiation expression

const x4 = f<true>
>x4 : Symbol(x4, Decl(instantiationExpressionErrors.ts, 44, 5))
>f : Symbol(f, Decl(instantiationExpressionErrors.ts, 0, 11))

if (true) {}

const x5 = f<true>
>x5 : Symbol(x5, Decl(instantiationExpressionErrors.ts, 47, 5))
>f : Symbol(f, Decl(instantiationExpressionErrors.ts, 0, 11))

let yy = 0;
>yy : Symbol(yy, Decl(instantiationExpressionErrors.ts, 48, 3))

const x6 = f<true>
>x6 : Symbol(x6, Decl(instantiationExpressionErrors.ts, 50, 5))
>f : Symbol(f, Decl(instantiationExpressionErrors.ts, 0, 11))

interface I {}
>I : Symbol(I, Decl(instantiationExpressionErrors.ts, 51, 9))

let x10 = f<true>
>x10 : Symbol(x10, Decl(instantiationExpressionErrors.ts, 53, 3))
>f : Symbol(f, Decl(instantiationExpressionErrors.ts, 0, 11))

this.bar()
>this : Symbol(globalThis)

let x11 = f<true>
>x11 : Symbol(x11, Decl(instantiationExpressionErrors.ts, 56, 3))
>f : Symbol(f, Decl(instantiationExpressionErrors.ts, 0, 11))

function bar() {}
>bar : Symbol(bar, Decl(instantiationExpressionErrors.ts, 56, 17))

let x12 = f<true>
>x12 : Symbol(x12, Decl(instantiationExpressionErrors.ts, 59, 3))
>f : Symbol(f, Decl(instantiationExpressionErrors.ts, 0, 11))

class C {}
>C : Symbol(C, Decl(instantiationExpressionErrors.ts, 59, 17))

let x13 = f<true>
>x13 : Symbol(x13, Decl(instantiationExpressionErrors.ts, 62, 3))
>f : Symbol(f, Decl(instantiationExpressionErrors.ts, 0, 11))

bar()

let x14 = f<true>
>x14 : Symbol(x14, Decl(instantiationExpressionErrors.ts, 65, 3))
>f : Symbol(f, Decl(instantiationExpressionErrors.ts, 0, 11))

void bar()

class C1 {
>C1 : Symbol(C1, Decl(instantiationExpressionErrors.ts, 66, 10))

    static specialFoo = f<string>
>specialFoo : Symbol(C1.specialFoo, Decl(instantiationExpressionErrors.ts, 68, 10))
>f : Symbol(f, Decl(instantiationExpressionErrors.ts, 0, 11))

    static bar = 123
>bar : Symbol(C1.bar, Decl(instantiationExpressionErrors.ts, 70, 10))
}

class C2 {
>C2 : Symbol(C2, Decl(instantiationExpressionErrors.ts, 71, 1))

    public specialFoo = f<string>
>specialFoo : Symbol(C2.specialFoo, Decl(instantiationExpressionErrors.ts, 73, 10))
>f : Symbol(f, Decl(instantiationExpressionErrors.ts, 0, 11))

    public bar = 123
>bar : Symbol(C2.bar, Decl(instantiationExpressionErrors.ts, 75, 10))
}

class C3 {
>C3 : Symbol(C3, Decl(instantiationExpressionErrors.ts, 76, 1))

    private specialFoo = f<string>
>specialFoo : Symbol(C3.specialFoo, Decl(instantiationExpressionErrors.ts, 78, 10))
>f : Symbol(f, Decl(instantiationExpressionErrors.ts, 0, 11))

    private bar = 123
>bar : Symbol(C3.bar, Decl(instantiationExpressionErrors.ts, 80, 11))
}

class C4 {
>C4 : Symbol(C4, Decl(instantiationExpressionErrors.ts, 81, 1))

    protected specialFoo = f<string>
>specialFoo : Symbol(C4.specialFoo, Decl(instantiationExpressionErrors.ts, 83, 10))
>f : Symbol(f, Decl(instantiationExpressionErrors.ts, 0, 11))

    protected bar = 123
>bar : Symbol(C4.bar, Decl(instantiationExpressionErrors.ts, 85, 13))
}

// Repro from #49551

const enum MyVer { v1 = 1, v2 = 2 }
>MyVer : Symbol(MyVer, Decl(instantiationExpressionErrors.ts, 86, 1))
>v1 : Symbol(MyVer.v1, Decl(instantiationExpressionErrors.ts, 90, 18))
>v2 : Symbol(MyVer.v2, Decl(instantiationExpressionErrors.ts, 90, 26))

let ver = 21
>ver : Symbol(ver, Decl(instantiationExpressionErrors.ts, 91, 3))

const a = ver < (MyVer.v1 >= MyVer.v2 ? MyVer.v1 : MyVer.v2)
>a : Symbol(a, Decl(instantiationExpressionErrors.ts, 92, 5))
>ver : Symbol(ver, Decl(instantiationExpressionErrors.ts, 91, 3))
>MyVer.v1 : Symbol(MyVer.v1, Decl(instantiationExpressionErrors.ts, 90, 18))
>MyVer : Symbol(MyVer, Decl(instantiationExpressionErrors.ts, 86, 1))
>v1 : Symbol(MyVer.v1, Decl(instantiationExpressionErrors.ts, 90, 18))
>MyVer.v2 : Symbol(MyVer.v2, Decl(instantiationExpressionErrors.ts, 90, 26))
>MyVer : Symbol(MyVer, Decl(instantiationExpressionErrors.ts, 86, 1))
>v2 : Symbol(MyVer.v2, Decl(instantiationExpressionErrors.ts, 90, 26))
>MyVer.v1 : Symbol(MyVer.v1, Decl(instantiationExpressionErrors.ts, 90, 18))
>MyVer : Symbol(MyVer, Decl(instantiationExpressionErrors.ts, 86, 1))
>v1 : Symbol(MyVer.v1, Decl(instantiationExpressionErrors.ts, 90, 18))
>MyVer.v2 : Symbol(MyVer.v2, Decl(instantiationExpressionErrors.ts, 90, 26))
>MyVer : Symbol(MyVer, Decl(instantiationExpressionErrors.ts, 86, 1))
>v2 : Symbol(MyVer.v2, Decl(instantiationExpressionErrors.ts, 90, 26))

